

## text-delta  
![img](./image.png) 
```
f:{"messageId":"d16c2a36-8f7d-422d-8027-882539ddd416"}
2:[{"type":"kind","content":"text"}]
2:[{"type":"id","content":"ac443f38-af97-4ef9-b32e-32f13fa8b476"}]
2:[{"type":"title","content":"The Evolution and Impact of Silicon Valley"}]
2:[{"type":"clear","content":""}]
9:{"toolCallId":"call_1apw0s50ffv6D7ZUO1UF7izG","toolName":"createDocument","args":{"title":"The Evolution and Impact of Silicon Valley","kind":"text"}}
2:[{"type":"text-delta","content":"# "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"Evolution "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Impact "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley\n\n"}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley, "}]
2:[{"type":"text-delta","content":"located "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"southern "}]
2:[{"type":"text-delta","content":"part "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"San "}]
2:[{"type":"text-delta","content":"Francisco "}]
2:[{"type":"text-delta","content":"Bay "}]
2:[{"type":"text-delta","content":"Area "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"California, "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"become "}]
2:[{"type":"text-delta","content":"synonymous "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"innovation, "}]
2:[{"type":"text-delta","content":"technology, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"entrepreneurship. "}]
2:[{"type":"text-delta","content":"Its "}]
2:[{"type":"text-delta","content":"evolution "}]
2:[{"type":"text-delta","content":"from "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"modest "}]
2:[{"type":"text-delta","content":"agricultural "}]
2:[{"type":"text-delta","content":"region "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"global "}]
2:[{"type":"text-delta","content":"epicenter "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"technology "}]
2:[{"type":"text-delta","content":"is "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"fascinating "}]
2:[{"type":"text-delta","content":"story "}]
2:[{"type":"text-delta","content":"that "}]
2:[{"type":"text-delta","content":"reflects "}]
2:[{"type":"text-delta","content":"broader "}]
2:[{"type":"text-delta","content":"trends "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"society, "}]
2:[{"type":"text-delta","content":"economy, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"culture.\n\n"}]
2:[{"type":"text-delta","content":"## "}]
2:[{"type":"text-delta","content":"Historical "}]
2:[{"type":"text-delta","content":"Background\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"Early "}]
2:[{"type":"text-delta","content":"Beginnings\n\n"}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"roots "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"can "}]
2:[{"type":"text-delta","content":"be "}]
2:[{"type":"text-delta","content":"traced "}]
2:[{"type":"text-delta","content":"back "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"early "}]
2:[{"type":"text-delta","content":"20th "}]
2:[{"type":"text-delta","content":"century "}]
2:[{"type":"text-delta","content":"when "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"area "}]
2:[{"type":"text-delta","content":"was "}]
2:[{"type":"text-delta","content":"primarily "}]
2:[{"type":"text-delta","content":"agricultural, "}]
2:[{"type":"text-delta","content":"known "}]
2:[{"type":"text-delta","content":"for "}]
2:[{"type":"text-delta","content":"its "}]
2:[{"type":"text-delta","content":"fruit "}]
2:[{"type":"text-delta","content":"orchards. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"transformation "}]
2:[{"type":"text-delta","content":"began "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"1930s "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"establishment "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"Stanford "}]
2:[{"type":"text-delta","content":"University, "}]
2:[{"type":"text-delta","content":"which "}]
2:[{"type":"text-delta","content":"played "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"crucial "}]
2:[{"type":"text-delta","content":"role "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"fostering "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"culture "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovation "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"entrepreneurship. \n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"Birth "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"Tech "}]
2:[{"type":"text-delta","content":"Industry\n\n"}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"post-World "}]
2:[{"type":"text-delta","content":"War "}]
2:[{"type":"text-delta","content":"II "}]
2:[{"type":"text-delta","content":"era "}]
2:[{"type":"text-delta","content":"marked "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"significant "}]
2:[{"type":"text-delta","content":"turning "}]
2:[{"type":"text-delta","content":"point. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"U.S. "}]
2:[{"type":"text-delta","content":"government "}]
2:[{"type":"text-delta","content":"invested "}]
2:[{"type":"text-delta","content":"heavily "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"research "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"development, "}]
2:[{"type":"text-delta","content":"particularly "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"electronics "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"defense. "}]
2:[{"type":"text-delta","content":"Companies "}]
2:[{"type":"text-delta","content":"like "}]
2:[{"type":"text-delta","content":"Hewlett-Packard "}]
2:[{"type":"text-delta","content":"(HP), "}]
2:[{"type":"text-delta","content":"founded "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"garage "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"1939, "}]
2:[{"type":"text-delta","content":"became "}]
2:[{"type":"text-delta","content":"pioneers "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"industry. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"term "}]
2:[{"type":"text-delta","content":"\"Silicon "}]
2:[{"type":"text-delta","content":"Valley\" "}]
2:[{"type":"text-delta","content":"itself "}]
2:[{"type":"text-delta","content":"was "}]
2:[{"type":"text-delta","content":"coined "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"1970s, "}]
2:[{"type":"text-delta","content":"referring "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"silicon "}]
2:[{"type":"text-delta","content":"chip "}]
2:[{"type":"text-delta","content":"technology "}]
2:[{"type":"text-delta","content":"that "}]
2:[{"type":"text-delta","content":"was "}]
2:[{"type":"text-delta","content":"being "}]
2:[{"type":"text-delta","content":"developed "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"region.\n\n"}]
2:[{"type":"text-delta","content":"## "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"Rise "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"Tech "}]
2:[{"type":"text-delta","content":"Giants\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"1980s "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"1990s\n\n"}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"1980s "}]
2:[{"type":"text-delta","content":"saw "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"rise "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"personal "}]
2:[{"type":"text-delta","content":"computing, "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"companies "}]
2:[{"type":"text-delta","content":"like "}]
2:[{"type":"text-delta","content":"Apple "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Intel "}]
2:[{"type":"text-delta","content":"leading "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"charge. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"dot-com "}]
2:[{"type":"text-delta","content":"boom "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"late "}]
2:[{"type":"text-delta","content":"1990s "}]
2:[{"type":"text-delta","content":"further "}]
2:[{"type":"text-delta","content":"solidified "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley's "}]
2:[{"type":"text-delta","content":"status "}]
2:[{"type":"text-delta","content":"as "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"hub, "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"numerous "}]
2:[{"type":"text-delta","content":"startups "}]
2:[{"type":"text-delta","content":"emerging "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"venture "}]
2:[{"type":"text-delta","content":"capital "}]
2:[{"type":"text-delta","content":"flowing "}]
2:[{"type":"text-delta","content":"into "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"region. "}]
2:[{"type":"text-delta","content":"This "}]
2:[{"type":"text-delta","content":"period "}]
2:[{"type":"text-delta","content":"was "}]
2:[{"type":"text-delta","content":"characterized "}]
2:[{"type":"text-delta","content":"by "}]
2:[{"type":"text-delta","content":"rapid "}]
2:[{"type":"text-delta","content":"innovation "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"birth "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"internet "}]
2:[{"type":"text-delta","content":"economy.\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"21st "}]
2:[{"type":"text-delta","content":"Century\n\n"}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"21st "}]
2:[{"type":"text-delta","content":"century "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"witnessed "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"emergence "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"social "}]
2:[{"type":"text-delta","content":"media "}]
2:[{"type":"text-delta","content":"giants "}]
2:[{"type":"text-delta","content":"like "}]
2:[{"type":"text-delta","content":"Facebook, "}]
2:[{"type":"text-delta","content":"Google, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Twitter, "}]
2:[{"type":"text-delta","content":"as "}]
2:[{"type":"text-delta","content":"well "}]
2:[{"type":"text-delta","content":"as "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"rise "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"mobile "}]
2:[{"type":"text-delta","content":"technology "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"companies "}]
2:[{"type":"text-delta","content":"like "}]
2:[{"type":"text-delta","content":"Apple "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Samsung. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"landscape "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"expanded "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"include "}]
2:[{"type":"text-delta","content":"artificial "}]
2:[{"type":"text-delta","content":"intelligence, "}]
2:[{"type":"text-delta","content":"biotechnology, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"renewable "}]
2:[{"type":"text-delta","content":"energy, "}]
2:[{"type":"text-delta","content":"making "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"diverse "}]
2:[{"type":"text-delta","content":"ecosystem "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovation.\n\n"}]
2:[{"type":"text-delta","content":"## "}]
2:[{"type":"text-delta","content":"Economic "}]
2:[{"type":"text-delta","content":"Impact\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"Job "}]
2:[{"type":"text-delta","content":"Creation "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Economic "}]
2:[{"type":"text-delta","content":"Growth\n\n"}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"been "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"significant "}]
2:[{"type":"text-delta","content":"driver "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"economic "}]
2:[{"type":"text-delta","content":"growth "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"United "}]
2:[{"type":"text-delta","content":"States. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"industry "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"created "}]
2:[{"type":"text-delta","content":"millions "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"jobs, "}]
2:[{"type":"text-delta","content":"not "}]
2:[{"type":"text-delta","content":"only "}]
2:[{"type":"text-delta","content":"within "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"companies "}]
2:[{"type":"text-delta","content":"but "}]
2:[{"type":"text-delta","content":"also "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"ancillary "}]
2:[{"type":"text-delta","content":"industries "}]
2:[{"type":"text-delta","content":"such "}]
2:[{"type":"text-delta","content":"as "}]
2:[{"type":"text-delta","content":"marketing, "}]
2:[{"type":"text-delta","content":"finance, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"logistics. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"region's "}]
2:[{"type":"text-delta","content":"GDP "}]
2:[{"type":"text-delta","content":"is "}]
2:[{"type":"text-delta","content":"among "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"highest "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"world, "}]
2:[{"type":"text-delta","content":"contributing "}]
2:[{"type":"text-delta","content":"significantly "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"national "}]
2:[{"type":"text-delta","content":"economy.\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"Global "}]
2:[{"type":"text-delta","content":"Influence\n\n"}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"influence "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"extends "}]
2:[{"type":"text-delta","content":"beyond "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"U.S. "}]
2:[{"type":"text-delta","content":"Its "}]
2:[{"type":"text-delta","content":"innovations "}]
2:[{"type":"text-delta","content":"have "}]
2:[{"type":"text-delta","content":"shaped "}]
2:[{"type":"text-delta","content":"global "}]
2:[{"type":"text-delta","content":"markets, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"many "}]
2:[{"type":"text-delta","content":"countries "}]
2:[{"type":"text-delta","content":"have "}]
2:[{"type":"text-delta","content":"attempted "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"replicate "}]
2:[{"type":"text-delta","content":"its "}]
2:[{"type":"text-delta","content":"success "}]
2:[{"type":"text-delta","content":"by "}]
2:[{"type":"text-delta","content":"creating "}]
2:[{"type":"text-delta","content":"their "}]
2:[{"type":"text-delta","content":"own "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"hubs. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"Valley's "}]
2:[{"type":"text-delta","content":"startups "}]
2:[{"type":"text-delta","content":"often "}]
2:[{"type":"text-delta","content":"set "}]
2:[{"type":"text-delta","content":"trends "}]
2:[{"type":"text-delta","content":"that "}]
2:[{"type":"text-delta","content":"resonate "}]
2:[{"type":"text-delta","content":"worldwide, "}]
2:[{"type":"text-delta","content":"impacting "}]
2:[{"type":"text-delta","content":"everything "}]
2:[{"type":"text-delta","content":"from "}]
2:[{"type":"text-delta","content":"consumer "}]
2:[{"type":"text-delta","content":"behavior "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"business "}]
2:[{"type":"text-delta","content":"practices.\n\n"}]
2:[{"type":"text-delta","content":"## "}]
2:[{"type":"text-delta","content":"Cultural "}]
2:[{"type":"text-delta","content":"Impact\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"Innovation "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Entrepreneurship\n\n"}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"fostered "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"culture "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovation "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"risk-taking. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"\"fail "}]
2:[{"type":"text-delta","content":"fast\" "}]
2:[{"type":"text-delta","content":"mentality "}]
2:[{"type":"text-delta","content":"encourages "}]
2:[{"type":"text-delta","content":"entrepreneurs "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"experiment "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"learn "}]
2:[{"type":"text-delta","content":"from "}]
2:[{"type":"text-delta","content":"their "}]
2:[{"type":"text-delta","content":"mistakes, "}]
2:[{"type":"text-delta","content":"leading "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"groundbreaking "}]
2:[{"type":"text-delta","content":"advancements. "}]
2:[{"type":"text-delta","content":"This "}]
2:[{"type":"text-delta","content":"culture "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"inspired "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"generation "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovators "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"been "}]
2:[{"type":"text-delta","content":"instrumental "}]
2:[{"type":"text-delta","content":"in "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"rise "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"startup "}]
2:[{"type":"text-delta","content":"ecosystem "}]
2:[{"type":"text-delta","content":"globally.\n\n"}]
2:[{"type":"text-delta","content":"### "}]
2:[{"type":"text-delta","content":"Diversity "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"Inclusion "}]
2:[{"type":"text-delta","content":"Challenges\n\n"}]
2:[{"type":"text-delta","content":"Despite "}]
2:[{"type":"text-delta","content":"its "}]
2:[{"type":"text-delta","content":"reputation "}]
2:[{"type":"text-delta","content":"as "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"beacon "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovation, "}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"faced "}]
2:[{"type":"text-delta","content":"criticism "}]
2:[{"type":"text-delta","content":"for "}]
2:[{"type":"text-delta","content":"its "}]
2:[{"type":"text-delta","content":"lack "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"diversity "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"inclusion. "}]
2:[{"type":"text-delta","content":"The "}]
2:[{"type":"text-delta","content":"tech "}]
2:[{"type":"text-delta","content":"industry "}]
2:[{"type":"text-delta","content":"has "}]
2:[{"type":"text-delta","content":"struggled "}]
2:[{"type":"text-delta","content":"with "}]
2:[{"type":"text-delta","content":"gender "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"racial "}]
2:[{"type":"text-delta","content":"disparities, "}]
2:[{"type":"text-delta","content":"prompting "}]
2:[{"type":"text-delta","content":"calls "}]
2:[{"type":"text-delta","content":"for "}]
2:[{"type":"text-delta","content":"change "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"greater "}]
2:[{"type":"text-delta","content":"representation "}]
2:[{"type":"text-delta","content":"within "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"workforce.\n\n"}]
2:[{"type":"text-delta","content":"## "}]
2:[{"type":"text-delta","content":"Conclusion\n\n"}]
2:[{"type":"text-delta","content":"Silicon "}]
2:[{"type":"text-delta","content":"Valley's "}]
2:[{"type":"text-delta","content":"evolution "}]
2:[{"type":"text-delta","content":"from "}]
2:[{"type":"text-delta","content":"an "}]
2:[{"type":"text-delta","content":"agricultural "}]
2:[{"type":"text-delta","content":"region "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"global "}]
2:[{"type":"text-delta","content":"technology "}]
2:[{"type":"text-delta","content":"powerhouse "}]
2:[{"type":"text-delta","content":"is "}]
2:[{"type":"text-delta","content":"a "}]
2:[{"type":"text-delta","content":"testament "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"power "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"innovation, "}]
2:[{"type":"text-delta","content":"entrepreneurship, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"collaboration. "}]
2:[{"type":"text-delta","content":"Its "}]
2:[{"type":"text-delta","content":"impact "}]
2:[{"type":"text-delta","content":"on "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"economy, "}]
2:[{"type":"text-delta","content":"culture, "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"society "}]
2:[{"type":"text-delta","content":"is "}]
2:[{"type":"text-delta","content":"profound, "}]
2:[{"type":"text-delta","content":"shaping "}]
2:[{"type":"text-delta","content":"not "}]
2:[{"type":"text-delta","content":"only "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"future "}]
2:[{"type":"text-delta","content":"of "}]
2:[{"type":"text-delta","content":"technology "}]
2:[{"type":"text-delta","content":"but "}]
2:[{"type":"text-delta","content":"also "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"way "}]
2:[{"type":"text-delta","content":"we "}]
2:[{"type":"text-delta","content":"live "}]
2:[{"type":"text-delta","content":"and "}]
2:[{"type":"text-delta","content":"work. "}]
2:[{"type":"text-delta","content":"As "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"Valley "}]
2:[{"type":"text-delta","content":"continues "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"evolve, "}]
2:[{"type":"text-delta","content":"it "}]
2:[{"type":"text-delta","content":"will "}]
2:[{"type":"text-delta","content":"be "}]
2:[{"type":"text-delta","content":"essential "}]
2:[{"type":"text-delta","content":"to "}]
2:[{"type":"text-delta","content":"address "}]
2:[{"type":"text-delta","content":"the "}]
2:[{"type":"text-delta","content":"challenges "}]
2:[{"type":"text-delta","content":"it "}]
2:[{"type":"text-delta","content":"faces, "}]
2:[{"type":"text-delta","content":"ensuring "}]
2:[{"type":"text-delta","content":"that "}]
2:[{"type":"text-delta","content":"its "}]
2:[{"type":"text-delta","content":"benefits "}]
2:[{"type":"text-delta","content":"are "}]
2:[{"type":"text-delta","content":"shared "}]
2:[{"type":"text-delta","content":"more "}]
2:[{"type":"text-delta","content":"equitably "}]
2:[{"type":"text-delta","content":"across "}]
2:[{"type":"text-delta","content":"society."}]
2:[{"type":"finish","content":""}]
a:{"toolCallId":"call_1apw0s50ffv6D7ZUO1UF7izG","result":{"id":"ac443f38-af97-4ef9-b32e-32f13fa8b476","title":"The Evolution and Impact of Silicon Valley","kind":"text","content":"A document was created and is now visible to the user."}}
e:{"finishReason":"tool-calls","usage":{"promptTokens":552,"completionTokens":25},"isContinued":false}
f:{"messageId":"d26590b3-0036-49af-be25-8367e18d8f76"}
0:"I've "
0:"created "
0:"a "
0:"document "
0:"titled "
0:"\"The "
0:"Evolution "
0:"and "
0:"Impact "
0:"of "
0:"Silicon "
0:"Valley.\" "
0:"You "
0:"can "
0:"view "
0:"and "
0:"edit "
0:"it "
0:"now. "
0:"Let "
0:"me "
0:"know "
0:"if "
0:"you "
0:"would "
0:"like "
0:"to "
0:"make "
0:"any "
0:"changes "
0:"or "
0:"add "
0:"specific "
0:"sections!"
e:{"finishReason":"stop","usage":{"promptTokens":638,"completionTokens":40},"isContinued":false}
d:{"finishReason":"stop","usage":{"promptTokens":1190,"completionTokens":65}}

```

## code-delta
```js
f:{"messageId":"0ae011e7-5af0-4ff2-9c9f-15b073849403"}
2:[{"type":"kind","content":"code"}]
2:[{"type":"id","content":"88cb32fc-a6d6-4560-9da1-60cf255cc937"}]
2:[{"type":"title","content":"Dijkstra's Algorithm Implementation"}]
2:[{"type":"clear","content":""}]
9:{"toolCallId":"call_8DG3yUIl2Dm6P0Gb8NBoGh0d","toolName":"createDocument","args":{"title":"Dijkstra's Algorithm Implementation","kind":"code"}}
2:[{"type":"code-delta","content":"import"}]
2:[{"type":"code-delta","content":"import heap"}]
2:[{"type":"code-delta","content":"import heapq"}]
2:[{"type":"code-delta","content":"import heapq\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n#"}]
2:[{"type":"code-delta","content":"import heapq\n\n# D"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef d"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    #"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store ("}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [("}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    #"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex:"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf')"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start]"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n       "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heap"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.he"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heapp"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n       "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        #"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n       "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex]."}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n           "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost +"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n           "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            #"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n           "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost <"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths["}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n               "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths["}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor]"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n               "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heap"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.he"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heapp"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, ("}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n#"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n   "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': "}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n#"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running D"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshort"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths ="}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = d"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph,"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\n"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\""}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from '"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A':"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {short"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {shortest"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {shortest_paths"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {shortest_paths}"}]
2:[{"type":"code-delta","content":"import heapq\n\n# Dijkstra's algorithm to find the shortest path in a graph\n\ndef dijkstra(graph, start):\n    # Create a priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each vertex\n    shortest_paths = {vertex: float('inf') for vertex in graph}\n    shortest_paths[start] = 0\n\n    while queue:\n        current_cost, current_vertex = heapq.heappop(queue)\n\n        # Explore neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            cost = current_cost + weight\n            # If found a shorter path to neighbor\n            if cost < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = cost\n                heapq.heappush(queue, (cost, neighbor))\n\n    return shortest_paths\n\n# Example graph represented as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\n# Running Dijkstra's algorithm from vertex 'A'\nshortest_paths = dijkstra(graph, 'A')\nprint(f\"Shortest paths from 'A': {shortest_paths}\")"}]
2:[{"type":"finish","content":""}]
a:{"toolCallId":"call_8DG3yUIl2Dm6P0Gb8NBoGh0d","result":{"id":"88cb32fc-a6d6-4560-9da1-60cf255cc937","title":"Dijkstra's Algorithm Implementation","kind":"code","content":"A document was created and is now visible to the user."}}
e:{"finishReason":"tool-calls","usage":{"promptTokens":553,"completionTokens":23},"isContinued":false}
f:{"messageId":"40c55ef0-8c11-42b6-9718-5e0bd64e5993"}
0:"I've "
0:"created "
0:"a "
0:"document "
0:"demonstrating "
0:"Dijkstra's "
0:"algorithm. "
0:"Please "
0:"let "
0:"me "
0:"know "
0:"if "
0:"you'd "
0:"like "
0:"to "
0:"update "
0:"it "
0:"or "
0:"if "
0:"you "
0:"have "
0:"any "
0:"specific "
0:"requests!"
e:{"finishReason":"stop","usage":{"promptTokens":635,"completionTokens":30},"isContinued":false}
d:{"finishReason":"stop","usage":{"promptTokens":1188,"completionTokens":53}}

```